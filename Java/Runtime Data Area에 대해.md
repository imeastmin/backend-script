RDA는 `Heap area`, `Method area`, `Native Method area`, `JVM Thread에 활성화 되는 Stack area`, `PC Register`로 구분됩니다.

- PC Register: JVM은 여러 개의 Thread를 실행할 수 있는데, 생성된 Thread는 PC Register를 갖게 됩니다. Thread가 생성되면 호출된 메소드를 실행하고, 실행된 메소드가 `*네이티브`가 아닐 경우 PC Register는 현재 실행 중인 JVM 명령의 주소를 저장합니다. 만약 현재 실행 중인 메소드가 `*네이티브 메소드`라면 PC Register 값은 정의되지 않습니다. 즉, JVM의 PC Register는 현재 실행 중인 JVM의 `명령 주소 값을 저장하는 역할`을 수행합니다.<br>_* 네이티브 메소드: 자바 언어가 아닌 다른 언어로 프로그래밍된 코드_

- Stack area: JVM Thread가 생성되면 동시에 Stack 영역이 각각의 Thread에 활성화 됩니다. Thread의 Stack 영역은 프레임을 저장합니다. 프레임에 관한 내용은 나중에 더 자세히 다루기로 하겠고 지금은 한 메소드가 실행될 때 필요한 값들을 저장하는 공간이라고 정의하겠습니다. 이 프레임은 Push, Pop을 통해 제어되고 Stacks-Base이기 때문에 프레임이 추가로 생성될 수 있습니다. 단어의 의미에서 알 수 있듯이 메소드가 호출 되면 프레임이 Push되고 종료가 되면 프레임이 Pop이 되어 프레임에 할당된 메모리를 모두 삭제합니다. Stack의 크기는 런타임시 동적으로 결정되고 개발자가 임의로 그 크기를 지정할 수도 있습니다. 

- Heap area: 모든 JVM Thread 간에 공유되는 메모리 공간입니다. Heap에는 `모든 클래스의 인스턴스, 배열에 대한 값들이 저장`됩니다. 객체에 대한 Heap Storage는 개발자가 명시적으로 관리하지 않고 가비지 컬렉터(GC, Garbage Collector)이라는 기능을 통해 사용하지 않는 Storage는 자동으로 회수됩니다. Heap의 크기는 런타임시 동적으로 결정되고 개발자가 임의로 그 크기를 지정할 수도 있습니다.

- Method area: 모든 JVM Thread 간에 공유되는 메모리 공간입니다. `*런타임 상수 풀`, 필드, 메소드 로컬 데이터, 메소드 코드, 생성자 코드 등 클래스의 구조에 대한 정보를 저장합니다.<br>_* 런타임 상수 풀: 클래스 정보가 로드될 때 생성되고, 런타임 시 반드시 확인이 필요한 상수들을 담아 놓는 공간입니다._

- Native Method area: 자바 프로그래밍 언어가 아닌 다른 언어로 작성된 네이티브 코드를 저장하는 영역입니다. 보통 C언어의 기능을 수행합니다.